#' Predictions from a bagged model
#'
#' The `predict()` function computes predictions from each of the
#'  models in the ensembles and returns a single aggregated value
#'  for each sample in `new_data`.
#' @param object An object generated by `bagger()`.
#' @param new_data A data frame of predictors. If a recipe or
#'  formula were originally used, the **original** data should be
#'  passed here instead of a preprocessed version.
#' @param type A single character value for the type of
#'  predictions. For regression models, `type = 'numeric'` is valid
#'  and `'class'` and `'prob'` are valid for classification models.
#' @param ... Not currently used.
#' @examples
#' data(airquality)
#'
#' set.seed(7687)
#' rule_fit <- bagger(Ozone ~ ., data = airquality, model = "model_rules", B = 5)
#' predict(rule_fit, new_data = airquality[, -1])
#' @export
predict.bagger <- function(object, new_data, type = NULL, ...) {
  type <- check_type(object, type)
  new_data <- hardhat::forge(new_data, object$blueprint)$predictors

  if (type == "numeric") {
    res <-
      map_dfr(object$model_df$.pred_form, eval_num_form, new_data) %>%
      group_by(.row) %>%
      summarize_all(mean, na.rm = TRUE) %>%
      ungroup() %>%
      select(-.row)

  } else {
    if (type == "class") {
      res <- class_pred(object$model_df, new_data)
    } else {
      lvl <- levels(mod$blueprint$ptypes$outcomes[[1]])
      res <- classprob_pred(object$model_df, new_data, lvl)
    }
  }
  res
}

# ------------------------------------------------------------------------------
# Note: These are temporary methods until we have a uniform interface via
# `tidypredict`

numeric_pred <- function(models, data) {
  n <- nrow(data)
  m <- nrow(models)
  preds <-
    purrr::map_df(models$model, predict, new_data = data, type = "numeric") %>%
    dplyr::mutate(.row = rep(1:n, m)) %>%
    dplyr::group_by(.row) %>%
    dplyr::summarize(
      # .n = sum(!is.na(.pred)),
      .pred = mean(.pred, na.rm = TRUE)
    ) %>%
    dplyr::arrange(.row) %>%
    dplyr::select(.pred)
  preds
}

cubist_pred <- function(models, data) {
  n <- nrow(data)
  m <- nrow(models)
  preds <-
    purrr::map_df(models$model, cb_wrap, data) %>%
    dplyr::mutate(.row = rep(1:n, m)) %>%
    dplyr::group_by(.row) %>%
    dplyr::summarize(
      # .n = sum(!is.na(.pred)),
      .pred = mean(.pred, na.rm = TRUE)
    ) %>%
    dplyr::arrange(.row) %>%
    dplyr::select(.pred)
  preds
}

cb_wrap <- function(x, dat) {
  tibble::tibble(.pred = predict(x, newdata = as.data.frame(dat)))
}

# TODO this should be driven from the probability predictions
class_pred <- function(models, data) {
  n <- nrow(data)
  m <- nrow(models)
  preds <-
    purrr::map_df(models$model, predict, new_data = data, type = "class") %>%
    dplyr::mutate(.row = rep(1:n, m)) %>%
    dplyr::group_by(.row, .pred_class) %>%
    dplyr::count() %>%
    dplyr::arrange(.row, desc(n)) %>%
    dplyr::group_by(.row) %>%
    dplyr::slice(1) %>%
    dplyr::ungroup() %>%
    dplyr::select(.pred_class)
  preds
}

classprob_pred <- function(models, data, lvl) {
  n <- nrow(data)
  m <- nrow(models)
  prob_cols <- paste0(".pred_", lvl)
  preds <-
    purrr::map_df(models$model, predict, new_data = data, type = "prob") %>%
    dplyr::mutate(.row = rep(1:n, m)) %>%
    dplyr::group_by(.row) %>%
    ## TODO normalize these
    dplyr::summarize_at(prob_cols, mean, na.rm = TRUE) %>%
    dplyr::arrange(.row) %>%
    dplyr::select(-.row)
  preds
}


