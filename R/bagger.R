#' Bagging functions
#'
#' General suite of bagging functions for several models.
#'
#' @param x A data frame, matrix, or recipe (depending on the method being used).
#' @param y A numeric or factor vector of outcomes. Categorical outcomes (i.e
#'  classes) should be represented as factors, not integers.
#' @param formula  An object of class "formula" (or one that can be coerced to
#'  that class): a symbolic description of the model to be fitted. Note that
#'  this package does not support multivariate outcomes and that, if some
#'  predictors are factors, dummy variables will _not_ be created unless by the
#'  underyling model function.
#' @param data A data frame containing the variables used in the formula or
#'  recipe.
#' @param model A single character value for the model being bagged. Possible
#'  values are "CART", "MARS", "C5.0" (classification only), and "model rules"
#'  (regression only).
#' @param times A single integer greater than 1 for the maximum number of bootstrap
#'  samples/ensemble members (some model fits might fail).
#' @param opt A named list (or NULL) of arguments to pass to the underlying
#'  model function. A list of possible arguments per model are given in Details.
#' @param extract A function (or NULL) that can extract model-related aspects
#'  of each ensemble member. See Details and example below.
#' @param control A list of options generated by `bag_control()`.
#' @param ... Optional arguments to pass to the `extract` function.
#' @details `bagger()` fits separate models to bootstrap samples. The
#'  prediction function for each model object is encoded in an R expression and
#'  the original model object is discarded. When making predictions, each
#'  prediction formula is evaluated on the new data and aggregated using the
#'  mean.
#'
#' Any arbitrary item can be saved from the model object (including the model
#'  object itself) using the `extract` argument, which should be a function with
#'  arguments `x`, and `...`. The results of this function are saved into a list
#'  column called `extras` (see the sample below).
#'
#' Variable importance scores are calculated using implementations in each
#'  package. When requested, the results are in a tibble with column names
#'  `term` (the predictor), `value` (the importance score), and `used` (the
#'  percentage of times that the variable was in the prediction equation).
#'
#' The models can be fit in parallel using the \pkg{future} package. The
#'  enable parallelism, use the `future::plan()` function to declare _how_ the
#'  computations should be distributed. Note that this will almost certainly
#'  multiple the memory requirements to fit the models.
#' @examples
#' library(rsample)
#' library(recipes)
#' library(dplyr)
#' library(yardstick)
#'
#' data(biomass)
#'
#' biomass_tr <-
#'   biomass %>%
#'   dplyr::filter(dataset == "Training") %>%
#'   dplyr::select(-dataset, -sample)
#'
#' biomass_te <-
#'   biomass %>%
#'   dplyr::filter(dataset == "Testing") %>%
#'   dplyr::select(-dataset, -sample)
#'
#' # ------------------------------------------------------------------------------
#'
#' perf <- metric_set(rmse, rsq, yardstick::ccc)
#'
#' ctrl <- bag_control(oob = perf, var_imp = TRUE)
#'
#' # ------------------------------------------------------------------------------
#'
#' # `times` is low to make the examples run faster
#'
#' set.seed(7687)
#' mars_fit <- bagger(x = biomass_tr[, -6], y = biomass_tr$HHV,
#'                    model = "MARS", times = 5, control = ctrl)
#' var_imp(mars_fit)
#'
#' set.seed(7687)
#' cart_fit <- bagger(x = biomass_tr[, -6], y = biomass_tr$HHV,
#'                    model = "CART", times = 5, control = ctrl)
#'
#' set.seed(7687)
#' rule_fit <- bagger(x = biomass_tr[, -6], y = biomass_tr$HHV,
#'                    model = "model rules", times = 5, control = ctrl)
#'
#'
#' # ------------------------------------------------------------------------------
#' # Other interfaces
#'
#' # Recipes can be used
#' biomass_rec <-
#'   recipe(HHV ~ ., data = biomass_tr) %>%
#'   step_pca(all_predictors())
#'
#' set.seed(7687)
#' cart_pca_fit <- bagger(biomass_rec, data = biomass_tr, model = "CART", times = 5,
#'                        control = ctrl)
#'
#' cart_pca_fit
#' cart_pca_fit$oob
#' cart_fit$oob
#'
#' # An example rule:
#' cart_pca_fit$model_df$.pred_form[[1]][[3]]
#'
#' # Using formulas
#' set.seed(7687)
#' rule_form<- bagger(HHV ~ ., data = biomass_tr, model = "model rules", times = 5,
#'                    control = ctrl)
#'
#' # ------------------------------------------------------------------------------
#' # Extracting model components
#'
#' num_term_nodes <- function(x, ...) {
#'   tibble(num_nodes = sum(x$frame$var == "<leaf>"))
#' }
#'
#' set.seed(7687)
#' with_extras <- bagger(x = biomass_tr[, -6], y = biomass_tr$HHV,
#'                    model = "CART", times = 5, extract = num_term_nodes)
#'
#' dplyr::bind_rows(with_extras$model_df$extras)
#' @export
bagger <- function(x, ...) {
  UseMethod("bagger")
}

#' @export
#' @rdname bagger
bagger.default <- function(x, ...) {
  stop("`bagger()` is not defined for a '", class(x)[1], "'.", call. = FALSE)
}

# XY method - data frame

#' @export
#' @rdname bagger
bagger.data.frame <-
  function(x,
           y,
           model = "CART",
           times = 10L,
           opt = NULL,
           control = bag_control(),
           extract = NULL,
           ...) {
    times <- integer_B(times)
    seed <- sample.int(10^5, 1)
    validate_args(model, times, opt, control, extract)

    processed <- hardhat::mold(x, y)
    bagger_bridge(processed, model, seed, times, opt, control, extract, ...)
  }

# XY method - matrix

#' @export
#' @rdname bagger
bagger.matrix <-
  function(x,
           y,
           model = "CART",
           times = 10L,
           opt = NULL,
           control = bag_control(),
           extract = NULL,
           ...) {
    times <- integer_B(times)
    seed <- sample.int(10^5, 1)
    validate_args(model, times, opt, control, extract)

    processed <- hardhat::mold(x, y)
    bagger_bridge(processed, model, seed, times, opt, control, extract, ...)
  }

# Formula method

#' @export
#' @rdname bagger
bagger.formula <-
  function(formula,
           data,
           model = "CART",
           times = 10L,
           opt = NULL,
           control = bag_control(),
           extract = NULL,
           ...) {
    times <- integer_B(times)
    seed <- sample.int(10^5, 1)
    validate_args(model, times, opt, control, extract)

    bp <- hardhat::default_formula_blueprint(indicators = FALSE)
    processed <- hardhat::mold(formula, data, blueprint = bp)
    bagger_bridge(processed, model, seed, times, opt, control, extract, ...)
  }

# Recipe method

#' @export
#' @rdname bagger
bagger.recipe <-
  function(x,
           data,
           model = "CART",
           times = 10L,
           opt = NULL,
           control = bag_control(),
           extract = NULL,
           ...) {
    times <- integer_B(times)
    seed <- sample.int(10^5, 1)
    validate_args(model, times, opt, control, extract)

    processed <- hardhat::mold(x, data)
    bagger_bridge(processed, model, seed, times, opt, control, extract, ...)
  }

# ------------------------------------------------------------------------------


#' Controlling the bagging process
#'
#' `bag_control()` can set options for ancillary aspects of the bagging process.
#'
#' @param var_imp A single logical: should variable importance scores be calculated?
#' @param oob A metric set created by [yardstick::metric_set()] or `NULL`. If not
#'  NULL, then the out-of-bag samples are used to estimate model performance.
#' @param allow_parallel A single logical: should the model fits be done in
#'  parallel (even if a parallel `plan()` has been created)?
#' @param sampling Either "none" or "down". For classification only. The
#' training data, after bootstrapping, will be sampled down within each class
#' (with replacement) to the size of the smallest class.
#' @return A list.
#' @export
bag_control <-
  function(var_imp = TRUE, oob = NULL, allow_parallel = TRUE, sampling = "none") {

    res <-
      list(
        var_imp = var_imp,
        oob = oob,
        allow_parallel = allow_parallel,
        sampling = sampling
      )

    validate_control(res)
  }

#' @export
print.bagger <- function(x, ...) {
  cat("Bagged ", x$model[1], " (", x$model[2], " with ",
      nrow(x$model_df), " members)\n", sep = "")

  if (!is.null(x$opt)) {
    cat("Additional model options:\n")
    opt_chr <- paste0("  ", names(x$opt), ": ", format(x$opt))
    cat(opt_chr, sep = "\n")
  }

  if (!is.null(x$imp)) {
    cat("\nVariable importance scores include:\n\n")
    print(x$imp)
    cat("\n")
  }

  invisible(x)
}

