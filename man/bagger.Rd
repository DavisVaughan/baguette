% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bagger.R
\name{bagger}
\alias{bagger}
\alias{bagger.default}
\alias{bagger.data.frame}
\alias{bagger.matrix}
\alias{bagger.formula}
\alias{bagger.recipe}
\title{Bagging functions}
\usage{
bagger(x, ...)

\method{bagger}{default}(x, ...)

\method{bagger}{data.frame}(
  x,
  y,
  model = "CART",
  times = 10L,
  opt = NULL,
  control = bag_control(),
  extract = NULL,
  ...
)

\method{bagger}{matrix}(
  x,
  y,
  model = "CART",
  times = 10L,
  opt = NULL,
  control = bag_control(),
  extract = NULL,
  ...
)

\method{bagger}{formula}(
  formula,
  data,
  model = "CART",
  times = 10L,
  opt = NULL,
  control = bag_control(),
  extract = NULL,
  ...
)

\method{bagger}{recipe}(
  x,
  data,
  model = "CART",
  times = 10L,
  opt = NULL,
  control = bag_control(),
  extract = NULL,
  ...
)
}
\arguments{
\item{x}{A data frame, matrix, or recipe (depending on the method being used).}

\item{...}{Optional arguments to pass to the \code{extract} function.}

\item{y}{A numeric or factor vector of outcomes. Categorical outcomes (i.e
classes) should be represented as factors, not integers.}

\item{model}{A single character value for the model being bagged. Possible
values are "CART", "MARS", "C5.0" (classification only), and "model rules"
(regression only).}

\item{times}{A single integer greater than 1 for the maximum number of bootstrap
samples/ensemble members (some model fits might fail).}

\item{opt}{A named list (or NULL) of arguments to pass to the underlying
model function. A list of possible arguments per model are given in Details.}

\item{control}{A list of options generated by \code{bag_control()}.}

\item{extract}{A function (or NULL) that can extract model-related aspects
of each ensemble member. See Details and example below.}

\item{formula}{An object of class "formula" (or one that can be coerced to
that class): a symbolic description of the model to be fitted. Note that
this package does not support multivariate outcomes and that, if some
predictors are factors, dummy variables will \emph{not} be created unless by the
underyling model function.}

\item{data}{A data frame containing the variables used in the formula or
recipe.}
}
\description{
General suite of bagging functions for several models.
}
\details{
\code{bagger()} fits separate models to bootstrap samples. The
prediction function for each model object is encoded in an R expression and
the original model object is discarded. When making predictions, each
prediction formula is evaluated on the new data and aggregated using the
mean.

Any arbitrary item can be saved from the model object (including the model
object itself) using the \code{extract} argument, which should be a function with
arguments \code{x}, and \code{...}. The results of this function are saved into a list
column called \code{extras} (see the sample below).

Variable importance scores are calculated using implementations in each
package. When requested, the results are in a tibble with column names
\code{term} (the predictor), \code{value} (the importance score), and \code{used} (the
percentage of times that the variable was in the prediction equation).

The models can be fit in parallel using the \pkg{future} package. The
enable parallelism, use the \code{future::plan()} function to declare \emph{how} the
computations should be distributed. Note that this will almost certainly
multiple the memory requirements to fit the models.
}
\examples{
library(rsample)
library(recipes)
library(dplyr)
library(yardstick)

data(biomass)

biomass_tr <-
  biomass \%>\%
  dplyr::filter(dataset == "Training") \%>\%
  dplyr::select(-dataset, -sample)

biomass_te <-
  biomass \%>\%
  dplyr::filter(dataset == "Testing") \%>\%
  dplyr::select(-dataset, -sample)

# ------------------------------------------------------------------------------

perf <- metric_set(rmse, rsq, yardstick::ccc)

ctrl <- bag_control(oob = perf, var_imp = TRUE)

# ------------------------------------------------------------------------------

# `times` is low to make the examples run faster

set.seed(7687)
mars_fit <- bagger(x = biomass_tr[, -6], y = biomass_tr$HHV,
                   model = "MARS", times = 5, control = ctrl)
var_imp(mars_fit)

set.seed(7687)
cart_fit <- bagger(x = biomass_tr[, -6], y = biomass_tr$HHV,
                   model = "CART", times = 5, control = ctrl)

set.seed(7687)
rule_fit <- bagger(x = biomass_tr[, -6], y = biomass_tr$HHV,
                   model = "model rules", times = 5, control = ctrl)


# ------------------------------------------------------------------------------
# Other interfaces

# Recipes can be used
biomass_rec <-
  recipe(HHV ~ ., data = biomass_tr) \%>\%
  step_pca(all_predictors())

set.seed(7687)
cart_pca_fit <- bagger(biomass_rec, data = biomass_tr, model = "CART", times = 5,
                       control = ctrl)

cart_pca_fit
cart_pca_fit$oob
cart_fit$oob

# An example rule:
cart_pca_fit$model_df$.pred_form[[1]][[3]]

# Using formulas
set.seed(7687)
rule_form<- bagger(HHV ~ ., data = biomass_tr, model = "model rules", times = 5,
                   control = ctrl)

# ------------------------------------------------------------------------------
# Extracting model components

num_term_nodes <- function(x, ...) {
  tibble(num_nodes = sum(x$frame$var == "<leaf>"))
}

set.seed(7687)
with_extras <- bagger(x = biomass_tr[, -6], y = biomass_tr$HHV,
                   model = "CART", times = 5, extract = num_term_nodes)

dplyr::bind_rows(with_extras$model_df$extras)
}
